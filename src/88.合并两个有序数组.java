// import java.util.Arrays;

/*
 * @lc app=leetcode.cn id=88 lang=java
 *
 * [88] 合并两个有序数组
 */

// @lc code=start
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // ------------------------------- 分割线 ---------------------------------
        // 方法一：最容易想到的就是nums1数组后面部分是空出来的，所以直接将nums2数组的数据放到nums1后面
        // 多出来的位置，再使用Arrays中内置的sort排方法进行排序
        // 由于Arrays.sort()方法是对快速排序的封装，所以时间复杂度是O((m + n)log(m + n))
        // 快速排序的空间复杂度为O(log(m + n))

        // for (int i = 0; i < n; ++i) {
        //     nums1[i + m] = nums2[i];
        // }
        // Arrays.sort(nums1);

        // ------------------------------- 分割线 ---------------------------------


        // ------------------------------- 分割线 ---------------------------------
        // 方法2：使用辅助空间sum数组，实际上就是两个有序表的合并，合并过后再赋值给nums1
        // 由于只需要遍历nums1和nums2两个数组就可以，所以时间复杂度为O(m + n)
        // 但是由于需要多余的存储空间，所以说空间复杂度为O(m + n)

        // int[] sum = new int[m + n];
        // int i = 0;
        // int j = 0;
        // int k = 0;
        // while (i < m && j < n) {
        //     if (nums1[i] < nums2[j]) {
        //         sum[k] = nums1[i];
        //         ++i; ++k;
        //     } else {
        //         sum[k] = nums2[j];
        //         ++j; ++k;
        //     }
        // }
        // while (i < m) {
        //     sum[k] = nums1[i];
        //     ++i; ++k;
        // }
        // while (j < n) {
        //     sum[k] = nums2[j];
        //     ++j; ++k;
        // }
        // for (int t = 0; t < m + n; ++t) {
        //     nums1[t] = sum[t];
        // }
        // ------------------------------- 分割线 ---------------------------------

        // ------------------------------- 分割线 ---------------------------------
        // 方法三：能不能不声明辅助存储空间呢？
        // 答案当然是可以的，不是最后合并过后的nums1数组是升序排列么，那么倒着看就是降序排列
        // 所以只要逆序比较数组即可，这种思路真的是妙哇
        // 在任意时刻nums1被放入后面的元素个数为m - i - 1, nums2别放入后面的元素个数为n - j - 1
        // 那么任意时刻nums1中多余的位置为i + j + 1 > i   ---->  这就说明了nums1中的元素永远不会被覆盖
        // 时间复杂度还是O(m + n)，由于没有多余的存储空间，所以空间复杂度是O(1)
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k] = nums1[i];
                --i; --k;
            } else {
                nums1[k] = nums2[j];
                --j; --k;
            }
        }
        while (i >= 0) {
            nums1[k] = nums1[i];
            --i; --k;
        }
        while (j >= 0) {
            nums1[k] = nums2[j];
            --j; --k;
        }
    }
}
// a@lc code=end

